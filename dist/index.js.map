{"version":3,"file":"index.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;ACVa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb,aAAa;AACb;AACA;AACA;;;;;;;;;;;ACNa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,qBAAqB,mBAAO,CAAC,gDAAc;AAC3C;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;AChCV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,qBAAqB,mBAAO,CAAC,gDAAc;AAC3C;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB,GAAG;AACpB;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;AC5BhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;ACVL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,uBAAuB,mBAAO,CAAC,oDAAgB;AAC/C,yBAAyB,mBAAO,CAAC,wDAAkB;AACnD,0BAA0B,mBAAO,CAAC,0DAAmB;AACrD,gCAAgC,mBAAO,CAAC,sEAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACpDhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,qBAAqB,mBAAO,CAAC,gDAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gBAAgB,4CAA4C,IAAI;AACzG;AACA;AACA,sBAAsB;;;;;;;;;;;ACjBT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,qBAAqB,mBAAO,CAAC,gDAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;ACbP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,gCAAgC,mBAAO,CAAC,oFAAuC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,qBAAqB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,QAAQ;AAClH;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;ACjGd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,eAAe;AACxC,mBAAmB,mBAAO,CAAC,kCAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+BAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;AChRT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,mBAAmB,mBAAO,CAAC,kCAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;UC/DzB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,mBAAO,CAAC,qEAA8B;AAChE,gCAAgC,mBAAO,CAAC,iFAAoC;AAC5E,qBAAqB,mBAAO,CAAC,2DAAyB;AACtD,gCAAgC,mBAAO,CAAC,iFAAoC;AAC5E,yBAAyB,mBAAO,CAAC,mEAA6B;AAC9D,uBAAuB,mBAAO,CAAC,+DAA2B;AAC1D,8BAA8B,mBAAO,CAAC,+EAAmC;AACzE,yBAAyB,mBAAO,CAAC,2DAAyB;AAC1D,4BAA4B,mBAAO,CAAC,uEAA+B;AACnE,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://ruleinterpreter/webpack/universalModuleDefinition","webpack://ruleinterpreter/./constant.ts","webpack://ruleinterpreter/./expression/BinaryOperation.ts","webpack://ruleinterpreter/./expression/ConditionalExpression.ts","webpack://ruleinterpreter/./expression/Expression.ts","webpack://ruleinterpreter/./expression/ExpressionConstructor.ts","webpack://ruleinterpreter/./expression/FieldReference.ts","webpack://ruleinterpreter/./expression/LiteralValue.ts","webpack://ruleinterpreter/./interpreter/FormularInterpreter.ts","webpack://ruleinterpreter/./parser/FormularParser.ts","webpack://ruleinterpreter/./tokeniser/FormularTokeniser.ts","webpack://ruleinterpreter/webpack/bootstrap","webpack://ruleinterpreter/./main.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ruleinterpreter\"] = factory();\n\telse\n\t\troot[\"ruleinterpreter\"] = factory();\n})(this, () => {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.REGEX = void 0;\nexports.REGEX = {\n    formularOperatorG: /(<=|>=|==|\\|\\||&&|!=|[+/\\-*=()<>?:])/g,\n    formularOperator: /(<=|>=|==|\\|\\||&&|!=|[+/\\-*=()<>?!:])/\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BinaryOperation = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Représente une opération binaire sur deux expressions.\n * @template T Le type d'entrée de l'expression.\n * @template R Le type de sortie des expressions.\n * @param {Expression<T, R>} left L'expression de gauche.\n * @param {Expression<T, R>} right L'expression de droite.\n * @param {(a: R, b: R) => number} operator La fonction opérateur qui prend deux valeurs de type R et retourne un nombre.\n \n */\nclass BinaryOperation extends Expression_1.Expression {\n    /**\n     * Crée une instance de BinaryOperation.\n    */\n    constructor(left, right, operator) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.operator = operator;\n    }\n    /**\n     * Exécute l'opération binaire sur l'objet donné.\n     * @param {T} obj L'objet sur lequel l'opération sera exécutée.\n     * @returns {number} Le résultat de l'opération binaire.\n     */\n    execute(obj) {\n        return this.operator(this.left.execute(obj), this.right.execute(obj));\n    }\n}\nexports.BinaryOperation = BinaryOperation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConditionalExpression = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Représente une expression conditionnelle qui retourne des valeurs basées sur une condition.\n * @template T Le type d'entrée de l'expression.\n * @template R Le type de sortie de l'expression conditionnelle.\n * @param {Expression<T, number>} condition L'expression qui détermine la condition à évaluer.\n * @param {Expression<T, R>} isTrue L'expression à exécuter si la condition est vraie.\n * @param {Expression<T, R>} isFalse L'expression à exécuter si la condition est fausse.\n */\nclass ConditionalExpression extends Expression_1.Expression {\n    constructor(condition, isTrue, isFalse) {\n        super();\n        this.condition = condition;\n        this.isTrue = isTrue;\n        this.isFalse = isFalse;\n    }\n    /**\n     * Exécute l'expression conditionnelle sur l'objet donné.\n     * @param {T} obj L'objet sur lequel l'expression sera évaluée.\n     * @returns {R} La valeur retournée par l'expression conditionnelle, basée sur l'évaluation de la condition.\n     */\n    execute(obj) {\n        return this.condition.execute(obj) != 0 ? this.isTrue.execute(obj) : this.isFalse.execute(obj);\n    }\n}\nexports.ConditionalExpression = ConditionalExpression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Expression = void 0;\n/**\n * Représente une expression abstraite qui définit une interface pour l'évaluation d'expressions.\n * @template T Le type d'entrée pour l'expression.\n * @template R Le type de résultat produit par l'expression.\n */\nclass Expression {\n}\nexports.Expression = Expression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExpressionConstructor = void 0;\nconst LiteralValue_1 = require(\"./LiteralValue\");\nconst FieldReference_1 = require(\"./FieldReference\");\nconst BinaryOperation_1 = require(\"./BinaryOperation\");\nconst ConditionalExpression_1 = require(\"./ConditionalExpression\");\nclass ExpressionConstructor {\n    static literalValue(value) {\n        return new LiteralValue_1.LiteralValue(value);\n    }\n    static fieldReference(fieldName) {\n        return new FieldReference_1.FieldReference(fieldName);\n    }\n    static addition(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a + b);\n    }\n    static substration(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a - b);\n    }\n    static multiplication(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a * b);\n    }\n    static division(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => {\n            if (b === 0)\n                throw new Error(\"Division by zero\");\n            return a / b;\n        });\n    }\n    static condition(condition, isTrue, isFalse) {\n        return new ConditionalExpression_1.ConditionalExpression(condition, isTrue, isFalse);\n    }\n    static equality(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a === b));\n    }\n    static superior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a > b));\n    }\n    static inferior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a < b));\n    }\n    static different(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a != b));\n    }\n    static or(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a || b));\n    }\n    static and(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a && b));\n    }\n}\nexports.ExpressionConstructor = ExpressionConstructor;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FieldReference = void 0;\nconst Expression_1 = require(\"./Expression\");\nclass FieldReference extends Expression_1.Expression {\n    constructor(filedName) {\n        super();\n        this.filedName = filedName;\n    }\n    execute(obj) {\n        if (obj != null && obj != undefined) {\n            if (obj[this.filedName] != undefined)\n                return obj[this.filedName];\n        }\n        throw new Error(`The fieldName ${this.filedName} not exist or equal to undefined on object ${obj}`);\n    }\n}\nexports.FieldReference = FieldReference;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiteralValue = void 0;\nconst Expression_1 = require(\"./Expression\");\nclass LiteralValue extends Expression_1.Expression {\n    constructor(_value) {\n        super();\n        this._value = _value;\n    }\n    execute(obj) {\n        return this._value;\n    }\n}\nexports.LiteralValue = LiteralValue;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormularInterpreter = void 0;\nconst ExpressionConstructor_1 = require(\"./../expression/ExpressionConstructor\");\nclass FormularInterpreter {\n    execute(astTree, data) {\n        const result = this.interprete(astTree, data).execute(data);\n        return result;\n    }\n    interprete(astTree, data) {\n        if (astTree.isNode()) {\n            const operator = astTree.operator;\n            const right = this.interprete(astTree.right, data);\n            const left = this.interprete(astTree.left, data);\n            switch (operator) {\n                case \"+\":\n                    return ExpressionConstructor_1.ExpressionConstructor.addition(left, right);\n                    break;\n                case \"-\":\n                    return ExpressionConstructor_1.ExpressionConstructor.substration(left, right);\n                    break;\n                case \"*\":\n                    return ExpressionConstructor_1.ExpressionConstructor.multiplication(left, right);\n                    break;\n                case \"/\":\n                    return ExpressionConstructor_1.ExpressionConstructor.division(left, right);\n                    break;\n                default:\n                    throw new Error(`This operator ${operator} is not supported.`);\n            }\n        }\n        else if (astTree.isValue()) {\n            const value = astTree.value;\n            if (typeof value === \"number\") {\n                return ExpressionConstructor_1.ExpressionConstructor.literalValue(Number(astTree.value));\n            }\n            else {\n                const regex = /\"([\\w]+)\"/;\n                const stringValue = value.match(regex)[1];\n                return ExpressionConstructor_1.ExpressionConstructor.literalValue(stringValue);\n            }\n        }\n        else if (astTree.isField()) {\n            const fieldValue = data[String(astTree.fieldName)];\n            if (fieldValue === undefined)\n                throw new Error(`The variable ${astTree.fieldName} not defined.`);\n            if (typeof fieldValue === \"number\") {\n                return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n            }\n            else {\n                return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n            }\n        }\n        else if (astTree.isComparaison()) {\n            const comparaisonOperator = astTree.operator;\n            const left = this.interprete(astTree.left, data);\n            const right = this.interprete(astTree.right, data);\n            switch (comparaisonOperator) {\n                case \">\":\n                    return ExpressionConstructor_1.ExpressionConstructor.superior(left, right);\n                    break;\n                case \"<\":\n                    return ExpressionConstructor_1.ExpressionConstructor.inferior(left, right);\n                    break;\n                case \"==\":\n                    return ExpressionConstructor_1.ExpressionConstructor.equality(left, right);\n                    break;\n                case \">=\":\n                    return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.superior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                    break;\n                case \"<=\":\n                    return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.inferior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                    break;\n                case \"||\":\n                    return ExpressionConstructor_1.ExpressionConstructor.or(left, right);\n                    break;\n                case \"&&\":\n                    return ExpressionConstructor_1.ExpressionConstructor.and(left, right);\n                    break;\n                case \"!=\":\n                    return ExpressionConstructor_1.ExpressionConstructor.different(left, right);\n                    break;\n                default:\n                    throw new Error(`This comparaison ${comparaisonOperator} methode is not supported`);\n            }\n        }\n        else if (astTree.isConditional()) {\n            const condition = this.interprete(astTree.condition, data);\n            const isTrue = this.interprete(astTree.isTrue, data);\n            const isFalse = this.interprete(astTree.isFalse, data);\n            return ExpressionConstructor_1.ExpressionConstructor.condition(condition, isTrue, isFalse);\n        }\n        else {\n            throw new Error(`This Expression is not Correct. Please verify You expression [Interpreter]:${astTree}`);\n        }\n    }\n}\nexports.FormularInterpreter = FormularInterpreter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormularParser = exports.AstNode = void 0;\nconst constant_1 = require(\"../constant\");\nclass AstNode {\n    isConditional() {\n        return !!this.condition && !!this.isFalse && !!this.isTrue;\n    }\n    isValue() {\n        return !!this.value;\n    }\n    isComparaison() {\n        return !!this.isComparaisonOperator();\n    }\n    isField() {\n        return !!this.fieldName;\n    }\n    isNode() {\n        return (!this.isValue() &&\n            !this.isField() &&\n            !this.isComparaison() &&\n            !this.isConditional());\n    }\n    isComparaisonOperator() {\n        if ([\">\", \"||\", \"<\", \"&&\", \">=\", \"<=\", \"==\", \"!=\"].includes(this.operator))\n            return true;\n        return false;\n    }\n}\nexports.AstNode = AstNode;\nclass FormularParser {\n    isFormular(tokens) {\n        let notOperatorLastIndex = 1;\n        let operatorLastIndex = 1;\n        const operatorRegex = constant_1.REGEX.formularOperator;\n        for (let index = 0; index < tokens.length; index++) {\n            const token = tokens[index];\n            const isOperator = operatorRegex.test(String(token));\n            const lastIndex = index - 1;\n            if (isOperator) {\n                operatorLastIndex = index;\n            }\n            else {\n                if (notOperatorLastIndex == lastIndex &&\n                    operatorLastIndex != lastIndex) {\n                    return false;\n                }\n                notOperatorLastIndex = index;\n            }\n        }\n        return true;\n    }\n    checkSynthax(tokens) {\n        this.checkParenthesixSynthax(tokens);\n        this.checkOperatorSynthax(tokens);\n        this.checkTernaryConditionSynthax(tokens);\n    }\n    checkParenthesixSynthax(tokens) {\n        const stack = [];\n        tokens.forEach((token) => {\n            if (token === \"(\")\n                stack.push(\"(\");\n            if (token === \")\") {\n                if (stack.length === 0) {\n                    throw new Error(\"Parenthesis mismatch\");\n                }\n                stack.pop();\n            }\n        });\n        if (stack.length !== 0) {\n            throw new Error(\"Incorrect parenthesis disposition.\");\n        }\n    }\n    checkOperatorSynthax(tokens) {\n        const regex = /[+-\\/*]{2,}/;\n        const expression = tokens.join(\"\");\n        if (regex.test(expression)) {\n            throw new Error(\"Incorrect Operator error\");\n        }\n        const validOperationCheckerRegex = />=|<=|==|!=|&&|\\|\\||[+-\\/*<>][\\w\\(]/;\n        if (!validOperationCheckerRegex.test(expression)) {\n            throw new Error(\"Incorrect Operator position for Operande\");\n        }\n    }\n    checkTernaryConditionSynthax(tokens) {\n        let ternaryQuestionMarkCount = 0;\n        let ternaryColonCount = 0;\n        tokens.forEach((token) => {\n            if (token === \"?\")\n                ternaryQuestionMarkCount++;\n            if (token === \":\")\n                ternaryColonCount++;\n        });\n        if (ternaryQuestionMarkCount !== ternaryColonCount) {\n            throw new Error(\"Incorrect Ternary syntax: unmatched ? and :\");\n        }\n        const ternaryRegex = /[?:]/;\n        let expectingCondition = true;\n        tokens.forEach((token) => {\n            if (ternaryRegex.test(String(token))) {\n                if (expectingCondition && token === \":\") {\n                    throw new Error(\"Ternary syntax error: found ':' before '?'\");\n                }\n                expectingCondition = !expectingCondition;\n            }\n        });\n    }\n    execute(tokens) {\n        if (this.isFormular(tokens)) {\n            this.checkSynthax(tokens);\n            return this.parser(tokens);\n        }\n        else {\n            throw new Error(\"is not formular\");\n        }\n    }\n    parser(tokens) {\n        console.log(tokens);\n        const postFixExpression = this.infixToPostFix(tokens);\n        console.log(postFixExpression);\n        const result = this.generateAST(postFixExpression);\n        return result;\n    }\n    generateAST(tokens) {\n        const stack = [];\n        let counter = 0;\n        return this._generateAST(tokens, counter, stack);\n    }\n    _generateAST(tokens, index, stack = []) {\n        const token = tokens[index];\n        if (!token)\n            return stack[0];\n        if (this.isOperatorFirstAndParenthesix(token)) {\n            const node = new AstNode();\n            node.operator = token;\n            if (this.isArithmeticOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isComparaisonOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isTernaryOperator(token)) {\n                node.isFalse = stack.pop();\n                node.isTrue = stack.pop();\n                node.condition = stack.pop();\n            }\n            stack.push(node);\n        }\n        else {\n            const node = new AstNode();\n            if (this.isValue(token)) {\n                node.value = token;\n            }\n            else {\n                node.fieldName = token;\n            }\n            stack.push(node);\n        }\n        return this._generateAST(tokens, index + 1, stack);\n    }\n    infixToPostFix(tokens) {\n        const output = [];\n        const operators = [];\n        tokens.forEach((token) => {\n            if (!this.isOperatorFirstAndParenthesix(token)) {\n                output.push(token);\n            }\n            else {\n                const operatorAndParentesix = String(token);\n                const priority = this.priority(operatorAndParentesix);\n                if (operatorAndParentesix === \"(\") {\n                    operators.push(operatorAndParentesix);\n                }\n                else if (operatorAndParentesix === \")\") {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== \"(\") {\n                        const operator = operators.pop();\n                        if (!(operator.trim() === \"(\")) {\n                            output.push(operator);\n                        }\n                    }\n                    operators.pop();\n                }\n                else if (operatorAndParentesix === \":\") {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== \"?\") {\n                        output.push(operators.pop());\n                    }\n                }\n                else if ([\n                    \"+\",\n                    \"-\",\n                    \"/\",\n                    \"*\",\n                    \">\",\n                    \"||\",\n                    \"<\",\n                    \"&&\",\n                    \">=\",\n                    \"<=\",\n                    \"==\",\n                    \"!=\",\n                    \"?\",\n                ].includes(operatorAndParentesix)) {\n                    while (operators.length > 0 &&\n                        this.priority(operators[operators.length - 1]) >= priority) {\n                        output.push(operators.pop());\n                    }\n                    operators.push(operatorAndParentesix);\n                }\n                else {\n                }\n            }\n        });\n        while (operators.length > 0) {\n            output.push(operators.pop());\n        }\n        return output;\n    }\n    priority(operator) {\n        if ([\"+\", \"-\"].includes(operator))\n            return 1;\n        if ([\"/\", \"*\"].includes(operator))\n            return 2;\n        if ([\">\", \"||\", \"<\", \"&&\", \">=\", \"<=\", \"==\", \"!=\", \"?\"].includes(operator))\n            return 3;\n        return 0;\n    }\n    isOperatorFirstAndParenthesix(token) {\n        if ([\n            \"+\",\n            \"-\",\n            \"/\",\n            \"*\",\n            \">\",\n            \"||\",\n            \"<\",\n            \"&&\",\n            \">=\",\n            \"<=\",\n            \"==\",\n            \"!=\",\n            \"?\",\n            \":\",\n            \"(\",\n            \")\",\n        ].includes(String(token).trim()))\n            return true;\n        return false;\n    }\n    isArithmeticOperator(token) {\n        if ([\"+\", \"-\", \"/\", \"*\"].includes(token))\n            return true;\n        return false;\n    }\n    isComparaisonOperator(token) {\n        if ([\">\", \"||\", \"<\", \"&&\", \">=\", \"<=\", \"==\", \"!=\"].includes(token))\n            return true;\n        return false;\n    }\n    isTernaryOperator(token) {\n        if ([\"?\"].includes(token))\n            return true;\n        return false;\n    }\n    isValue(token) {\n        const valueRegex = /\"[\\w]+\"/;\n        return typeof token === \"number\" || valueRegex.test(token) ? true : false;\n    }\n}\nexports.FormularParser = FormularParser;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormularTokeniser = void 0;\nconst constant_1 = require(\"../constant\");\nclass FormularTokeniser {\n    formatInput(input) {\n        const formatedExpression = input\n            .replace(constant_1.REGEX.formularOperatorG, \" $1 \")\n            .replace(/\\s+/g, \" \")\n            .trim();\n        return formatedExpression;\n    }\n    filterTokens(tokens) {\n        const filteredTokens = [];\n        let expectedClosedParenthesix = false;\n        tokens.forEach((token) => {\n            const regex = /^\\d+(\\.\\d+)?$/;\n            const negativeNumberRegex = /-\\d+/;\n            const lastFilteredToken = filteredTokens[filteredTokens.length - 1];\n            if (regex.test(token)) {\n                const firstPop = filteredTokens.pop();\n                const secondPop = filteredTokens.pop();\n                if (firstPop && secondPop) {\n                    if ([\"+\", \"-\"].includes(firstPop) && secondPop === \"(\") {\n                        filteredTokens.push(Number(firstPop + token));\n                        expectedClosedParenthesix = true;\n                    }\n                    else {\n                        filteredTokens.push(secondPop, firstPop, Number(token));\n                    }\n                }\n                else {\n                    if (!secondPop) {\n                        if (firstPop) {\n                            filteredTokens.push(firstPop, Number(token));\n                        }\n                        else {\n                            filteredTokens.push(Number(token));\n                        }\n                    }\n                    else {\n                        filteredTokens.push(Number(token));\n                    }\n                }\n            }\n            else if (negativeNumberRegex.test(lastFilteredToken) &&\n                token === \")\" &&\n                expectedClosedParenthesix) {\n                expectedClosedParenthesix = false;\n            }\n            else {\n                filteredTokens.push(token);\n            }\n        });\n        return filteredTokens;\n    }\n    execute(input) {\n        const formatedInput = this.formatInput(input);\n        const tokens = formatedInput.split(\" \");\n        const filteredTokens = this.filterTokens(tokens);\n        return filteredTokens;\n    }\n}\nexports.FormularTokeniser = FormularTokeniser;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BinaryOperation_1 = require(\"./expression/BinaryOperation\");\nconst ConditionalExpression_1 = require(\"./expression/ConditionalExpression\");\nconst Expression_1 = require(\"./expression/Expression\");\nconst ExpressionConstructor_1 = require(\"./expression/ExpressionConstructor\");\nconst FieldReference_1 = require(\"./expression/FieldReference\");\nconst LiteralValue_1 = require(\"./expression/LiteralValue\");\nconst FormularInterpreter_1 = require(\"./interpreter/FormularInterpreter\");\nconst FormularParser_1 = require(\"./parser/FormularParser\");\nconst FormularTokeniser_1 = require(\"./tokeniser/FormularTokeniser\");\nexports.default = {\n    BinaryOperation: BinaryOperation_1.BinaryOperation,\n    ConditionalExpression: ConditionalExpression_1.ConditionalExpression,\n    Expression: Expression_1.Expression,\n    ExpressionConstructor: ExpressionConstructor_1.ExpressionConstructor,\n    FieldReference: FieldReference_1.FieldReference,\n    LiteralValue: LiteralValue_1.LiteralValue,\n    FormularInterpreter: FormularInterpreter_1.FormularInterpreter,\n    FormularParser: FormularParser_1.FormularParser,\n    AstNode: FormularParser_1.AstNode,\n    FormularTokeniser: FormularTokeniser_1.FormularTokeniser,\n};\n"],"names":[],"sourceRoot":""}