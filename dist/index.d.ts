// Generated by dts-bundle v0.7.3

const _default: {
    BinaryOperation: typeof BinaryOperation;
    ConditionalExpression: typeof ConditionalExpression;
    Expression: typeof Expression;
    ExpressionConstructor: typeof ExpressionConstructor;
    FieldReference: typeof FieldReference;
    LiteralValue: typeof LiteralValue;
    FormularInterpreter: typeof FormularInterpreter;
    FormularParser: typeof FormularParser;
    AstNode: typeof AstNode;
    FormularTokeniser: typeof FormularTokeniser;
};
export default _default;

/**
    * Représente une opération binaire sur deux expressions.
    * @template T Le type d'entrée de l'expression.
    * @template R Le type de sortie des expressions.
    * @param {Expression<T, R>} left L'expression de gauche.
    * @param {Expression<T, R>} right L'expression de droite.
    * @param {(a: R, b: R) => number} operator La fonction opérateur qui prend deux valeurs de type R et retourne un nombre.
 
    */
export class BinaryOperation<T, R> extends Expression<T, number> {
        /**
            * Crée une instance de BinaryOperation.
         */
        constructor(left: Expression<T, R>, right: Expression<T, R>, operator: (a: R, b: R) => number);
        /**
            * Exécute l'opération binaire sur l'objet donné.
            * @param {T} obj L'objet sur lequel l'opération sera exécutée.
            * @returns {number} Le résultat de l'opération binaire.
            */
        execute(obj: T): number;
}

/**
    * Représente une expression conditionnelle qui retourne des valeurs basées sur une condition.
    * @template T Le type d'entrée de l'expression.
    * @template R Le type de sortie de l'expression conditionnelle.
    * @param {Expression<T, number>} condition L'expression qui détermine la condition à évaluer.
    * @param {Expression<T, R>} isTrue L'expression à exécuter si la condition est vraie.
    * @param {Expression<T, R>} isFalse L'expression à exécuter si la condition est fausse.
    */
export class ConditionalExpression<T, R> extends Expression<T, R> {
        constructor(condition: Expression<T, number>, isTrue: Expression<T, R>, isFalse: Expression<T, R>);
        /**
            * Exécute l'expression conditionnelle sur l'objet donné.
            * @param {T} obj L'objet sur lequel l'expression sera évaluée.
            * @returns {R} La valeur retournée par l'expression conditionnelle, basée sur l'évaluation de la condition.
            */
        execute(obj: T): R;
}

/**
    * Représente une expression abstraite qui définit une interface pour l'évaluation d'expressions.
    * @template T Le type d'entrée pour l'expression.
    * @template R Le type de résultat produit par l'expression.
    */
export abstract class Expression<T, R> {
        /**
            * Évalue l'expression en fonction de l'objet donné.
            * @param {T} obj L'objet sur lequel l'expression sera évaluée.
            * @returns {R} Le résultat de l'évaluation de l'expression.
            */
        abstract execute(obj: T): R;
}

export class ExpressionConstructor {
    static literalValue<T, R = number>(value: R): Expression<T, R>;
    static fieldReference<T extends {
        [key: string]: any;
    }, R>(fieldName: string): Expression<T, R>;
    static addition<T>(left: Expression<T, number>, right: Expression<T, number>): Expression<T, number>;
    static substration<T>(left: Expression<T, number>, right: Expression<T, number>): Expression<T, number>;
    static multiplication<T>(left: Expression<T, number>, right: Expression<T, number>): Expression<T, number>;
    static division<T>(left: Expression<T, number>, right: Expression<T, number>): Expression<T, number>;
    static condition<T, R>(condition: Expression<T, number>, isTrue: Expression<T, R>, isFalse: Expression<T, R>): Expression<T, R>;
    static equality<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
    static superior<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
    static inferior<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
    static different<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
    static or<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
    static and<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
}

export class FieldReference<T extends {
    [kex: string]: any;
}, R> extends Expression<T, R> {
    constructor(filedName: string);
    execute(obj: T): R;
}

export class LiteralValue<T, R = number> extends Expression<T, R> {
    constructor(_value: R);
    execute(obj: T): R;
}

type VariableContainer = {
    [key: string]: string | number;
};
export class FormularInterpreter {
    execute<T extends VariableContainer>(astTree: Node, data: T): number | string;
    interprete<T extends VariableContainer>(astTree: Node, data: T): Expression<T, string | number>;
}
export {};

type Operator = "+" | "-" | "/" | "*" | ">" | "||" | "<" | "&&" | ">=" | "<=" | "==" | "!=";
export interface Node {
    operator?: Operator;
    left?: Node;
    right?: Node;
    condition?: Node;
    isTrue?: Node;
    isFalse?: Node;
    value?: number | string;
    fieldName?: string;
    isConditional(): boolean;
    isValue(): boolean;
    isComparaison(): boolean;
    isField(): boolean;
    isNode(): boolean;
}
export class AstNode implements Node {
    operator?: Operator;
    left?: Node;
    right?: Node;
    condition?: Node;
    isTrue?: Node;
    isFalse?: Node;
    value?: number | string;
    fieldName?: string;
    isConditional(): boolean;
    isValue(): boolean;
    isComparaison(): boolean;
    isField(): boolean;
    isNode(): boolean;
}
export class FormularParser {
    execute(tokens: (string | number)[]): Node;
}
export {};

export class FormularTokeniser {
    formatInput(input: string): string;
    filterTokens(tokens: string[]): (string | number)[];
    execute(input: string): any[];
}

